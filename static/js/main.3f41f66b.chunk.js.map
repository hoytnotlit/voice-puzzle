{"version":3,"sources":["srgs.js","chartparser.js","runparser.js","dmPuzzle.ts","grammars/puzzleGrammar.ts","dmSettings.ts","grammars/settingsGrammar.ts","index.tsx"],"names":["Grammar","root","this","$root","VOID","OneOf","NULL","GARBAGE","$check","i","checkSequenceExpansion","err","throwRuleError","Ref","ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","min","max","sequence","RepeatClass","ruleref","content","_string","toString","join","Infinity","message","error","undefined","TypeError","constructor","Array","name","String","checkExpansion","prototype","Number","LOG","str","clone","obj","temp","key","isEmpty","ob","hasOwnProperty","Chart","numberOfWords","passives","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","ActiveEdge","rest","rules","text","parse","words","grammar","filter","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","oneof","eval","position","leftCorners","pop","active","passive","loadGrammar","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","send","responseXML","parseXML","getElementsByTagName","getAttribute","xrules","r","xrule","processRuleExpansions","xitems","childNodes","rule","nodeType","textContent","trim","split","nodeName","uri","repeat","parseInt","console","log","gram","commands","getGrammarResult","recResult","res","toLowerCase","puzzleMove","say","_context","type","value","getDefaultStates","prompt","on","ENDSPEECH","entry","context","reprompt","listen","getDefaultEvents","help_msg","target","cond","actions","assign","piece","degree","direction","indexOf","dmMachine","initial","states","init","CLICK","welcome","afterShuffle","play","RECOGNISED","id","hist","history","redirect","always","pieceSelected","help","win","lose","afterRotate","rotate","WIN","moves","CONTINUE","LOSE","select","shuffle","reset","setting","ask","SETTINGS","image","afterAnswer","change","confirm","mode","cancel","inspect","iframe","machine","Machine","dm","dmMachinePuzzle","settings","dmMachineSettings","asrtts","idle","LISTEN","SPEAK","event","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","test","ReactiveButton","props","state","matches","className","finishedPiecesCount","App","currentValue","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","result","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","ttsStart","effect","ttsCancel","rotatePiece","pieceId","document","getElementById","currDegree","style","transform","degreeToRotate","getDegree","classList","remove","shufflePieces","board","labels","info","pieces","children","degrees","htmlElement","randomDegree","Math","floor","random","resetBoard","selectPiece","transformVal","changeImage","backgroundImage","current","onClick","rootElement","ReactDOM"],"mappings":"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","file":"static/js/main.3f41f66b.chunk.js","sourcesContent":["//\r\n//  srgs.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// encoding SRGS grammars in javascript\r\n\r\nexport function Grammar(root) {\r\n  this.$root = root;\r\n  \r\n  this.VOID = [OneOf([])];\r\n  this.NULL = [];\r\n  this.GARBAGE = []; \r\n  \r\n  this.$check = function() {\r\n    for (var i in this) {\r\n      if (i !== \"$root\" && i !== \"$check\") {\r\n\ttry {\r\n\t  checkSequenceExpansion(this[i]);\r\n\t} catch(err) {\r\n\t  throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\r\n\t}\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function WordSet(str) {\r\n  var words = str.split(/ +/);\r\n  var set = {};\r\n  for (var i in words) {\r\n    set[words[i]] = true;\r\n  }\r\n  return set;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// rule expansion constructors\r\n\r\n// sequences are ordinary arrays\r\nexport function Sequence(seq) {\r\n  return seq;\r\n}\r\n\r\nexport function Ref(ref) {\r\n  return new RefClass(ref);\r\n}\r\n\r\nexport function Tag(tag) {\r\n  return new TagClass(tag);\r\n}\r\n\r\nexport function OneOf(alternatives) {\r\n  return new OneOfClass(alternatives);\r\n}\r\n\r\nexport function Repeat(min, max, sequence) {\r\n  return new RepeatClass(min, max, sequence);\r\n}\r\n\r\nexport function Optional(sequence) {\r\n  return new RepeatClass(0, 1, sequence);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// rule expansion classes\r\n\r\nexport function RefClass(ruleref) {\r\n  this.content = ruleref;\r\n  this._string = \"$\" + ruleref;\r\n  this.toString = function toString() {return this._string}\r\n}\r\n    \r\nexport function TagClass(tag) {\r\n  this.content = tag;\r\n  this._string = \"{\" + tag + \"}\";\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\nexport function OneOfClass(alternatives) {\r\n  this.content = alternatives;\r\n  this._string = \"(\" + alternatives.join(\"|\") + \")\";\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\nexport function RepeatClass(min, max, sequence) {\r\n  this.min = min;\r\n  this.max = max;\r\n  this.content = sequence;\r\n  this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// checking rule expansions\r\n\r\nexport function throwRuleError(message, error) {\r\n  if (error == undefined) {\r\n    throw TypeError(message);\r\n  } else {\r\n    throw TypeError(message + \"; \" + error.message);\r\n  }\r\n}\r\n\r\nexport function checkSequenceExpansion(sequence) {\r\n  try {\r\n    if (sequence.constructor !== Array) {\r\n      throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\r\n    }\r\n    for (var i in sequence) {\r\n      if (sequence[i].constructor == Array) {\r\n\tcheckSequenceExpansion(sequence[i]);\r\n      } else if (sequence[i].constructor != String) {\r\n\tsequence[i].checkExpansion();\r\n      }\r\n    }\r\n  } catch(err) {\r\n    throwRuleError(\"When checking sequence expansion\", err);\r\n  }\r\n};\r\n\r\nRefClass.prototype.checkExpansion = function checkExpansion() {\r\n  if (this.content.constructor !== String) {\r\n    throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\r\n  }\r\n};\r\n\r\nTagClass.prototype.checkExpansion = function checkExpansion() {\r\n  if (this.content.constructor !== String) {\r\n      throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\r\n  }\r\n};\r\n\r\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\r\n  try {\r\n    if (this.content.constructor !== Array) {\r\n      throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\r\n    }\r\n    for (var i in this.content) {\r\n      checkSequenceExpansion(this.content[i]);\r\n    }\r\n  } catch(err) {\r\n    throwRuleError(\"When checking OneOf content\", err);\r\n  }\r\n};\r\n\r\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\r\n  try {\r\n    if (this.min.constructor !== Number || this.max.constructor !== Number) {\r\n      throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\r\n    }\r\n    if (!(0 <= this.min && this.min <= this.max)) {\r\n      throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\r\n    }\r\n    checkSequenceExpansion(this.content);\r\n  } catch(err) {\r\n    throwRuleError(\"When checking Repeat content\", err);\r\n  }\r\n};\r\n\r\n","//\r\n//  chartparser.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/* Mods by Torbjörn\r\n- Removed the toString() method from Object. Why does it still work?\r\n- Added a text variable (similar to rules). See \r\n*/\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// a logging function\r\n//  - uncomment if you want to debug the parsing process\r\nfunction LOG(str) {\r\n  //console.log(\"\" + str);\r\n}\r\n\r\nimport * as SRGS from './srgs'\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// we need to be able to clone objects between different edges\r\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\r\nfunction clone(obj){\r\n  if (obj == null || typeof(obj) != 'object') {\r\n    return obj;\r\n  }\r\n  var temp = new obj.constructor(); \r\n  for (var key in obj) {\r\n    temp[key] = clone(obj[key]);\r\n  }\r\n  return temp;\r\n}\r\n\r\n\r\nfunction isEmpty(ob){\r\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\r\n  return true;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// parse chart\r\n// conceptually this is a set of edges, but it is optimized\r\nfunction Chart(numberOfWords) {\r\n  this.numberOfWords = numberOfWords;\r\n  this.passives = new Array(numberOfWords);\r\n  this.actives = new Array(numberOfWords);\r\n  for (var i = 0; i <= numberOfWords; i++) {\r\n    this.passives[i] = {};\r\n    this.actives[i] = {};\r\n  }\r\n\r\n  // Chart.add(edge)\r\n  // add the edge to the chart, return true if the chart was changed \r\n  // (i.e. if the chart didn't already contain the edge)\r\n  this.add = function add(edge) {\r\n    var subchart, cat;\r\n    if (edge.isPassive) {\r\n      subchart = this.passives[edge.start];\r\n      cat = edge.lhs;\r\n    } else {\r\n      subchart = this.actives[edge.end];\r\n      cat = edge.next.content;\r\n    }\r\n    if (!(cat in subchart)) {\r\n      subchart[cat] = {};\r\n    }\r\n    if (edge in subchart[cat]) {\r\n      return false;\r\n    } else {\r\n      subchart[cat][edge] = edge;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Chart.resultsForRule(lhs, start, end)\r\n  // return all parse results for the given lhs, start, and end\r\n  //  - start, end are optional; defaults to 0, numberOfWords\r\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\r\n    start = start || 0;\r\n    end = end || numberOfWords;\r\n    var results = [];\r\n    var finalEdges = this.passives[start][lhs];\r\n    for (var i in finalEdges) {\r\n      if (finalEdges[i].end == end) {\r\n\tresults.push(finalEdges[i].out);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\r\n  // return an array of all (passive/active) edges in the chart\r\n  this.allEdges = function allEdges() {\r\n    return this.allPassiveEdges().concat(this.allActiveEdges());\r\n  }\r\n  this.allPassiveEdges = function allPassiveEdges() {\r\n    var edges = [];\r\n    for (var i in this.passives) \r\n      for (var j in this.passives[i]) \r\n\tfor (var k in this.passives[i][j])\r\n\t  edges.push(this.passives[i][j][k]);\r\n    return edges;\r\n  }\r\n  this.allActiveEdges = function allActiveEdges() {\r\n    var edges = [];\r\n    for (var i in this.actives) \r\n      for (var j in this.actives[i]) \r\n\tfor (var k in this.actives[i][j])\r\n\t  edges.push(this.actives[i][j][k]);\r\n    return edges;\r\n  }\r\n\r\n  // Chart.statistics()\r\n  // return the number of edges in the chart\r\n  this.statistics = function statistics() {\r\n    var passives = this.allPassiveEdges().length;\r\n    var actives = this.allActiveEdges().length;\r\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\r\n  }\r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// parse edges: passive and active\r\n\r\nfunction PassiveEdge(start, end, lhs, out) {\r\n  this.start = start;\r\n  this.end = end;\r\n  this.lhs = lhs;\r\n  this.out = out;\r\n  this.isPassive = true;\r\n\r\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\r\n  this._string = str;\r\n  this.toString = function toString() {return this._string;} \r\n}\r\n\r\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\r\n  this.start = start;\r\n  this.end = end;\r\n  this.lhs = lhs;\r\n  this.next = next;\r\n  this.rest = rest;\r\n  this.out = out;\r\n  this.rules = rules;\r\n  this.text = text;\r\n  this.isPassive = false;\r\n\r\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \r\n    \", \" + rest + \" := \" + out + \" <- \" + rules;\r\n  this._string = str;\r\n  this.toString = function toString() {return this._string;} \r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// the main parsing function: a simple top-down chartparser\r\n//  - 'words' is an array of strings\r\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\r\n//  - 'root' is the starting category (a string)\r\n//    if unspecified, use the '$root' property of the grammar\r\n//  - 'filter' is an optional left-corner filter \r\n//    (a mapping from categories/rule-refs to words)\r\n//    if specified, it is used when predicting new edges\r\n// returns the final chart\r\nexport function parse(words, grammar, root, filter) {\r\n  if (!root) {\r\n    root = grammar.$root;\r\n  }\r\n  var chart = new Chart(words.length);\r\n  var agenda = [];\r\n\r\n  var leftCornerFilter;\r\n  if (filter == undefined) {\r\n    leftCornerFilter = function() {return true};\r\n  } else {\r\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\r\n      var leftCorners = filter[ruleref];\r\n      return leftCorners ? words[position] in leftCorners : true;\r\n    }\r\n  }\r\n  \r\n  // add an edge to the chart and the agenda, if it does not already exist\r\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\r\n    var edge;\r\n    if (rhs.length > 0) {\r\n      var next = rhs[0];\r\n      var rest = rhs.slice(1);\r\n      switch (next.constructor) {\r\n\t\r\n      case Array:\r\n\t// the next symbol is a sequence\r\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\r\n\treturn;\r\n\t\r\n      case SRGS.RepeatClass:\r\n\t// the next symbol is a repetition\r\n\tvar min = next.min;\r\n\tvar max = next.max;\r\n\t// skip repeat \r\n\tif (min <= 0) {\r\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\r\n\t}\r\n\t// repeat \r\n\tif (max > 0) {\r\n\t  var content = next.content;\r\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\r\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\r\n\t}\r\n\treturn;\r\n\t\r\n      case SRGS.OneOfClass:\r\n\t// the next symbol is a disjunction\r\n\tvar oneof = next.content;\r\n\tfor (var i in oneof) {\r\n\t  var rhs = oneof[i].concat(rest);\r\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\r\n\t} \r\n\treturn;\r\n\t\r\n      case SRGS.TagClass:\r\n\t// the next symbol is a semantic action\r\n\tout = clone(out);\r\n\trules = clone(rules);\r\n\teval(next.content);\r\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\r\n\treturn;\r\n      }\r\n\r\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\r\n    } else {\r\n      edge = new PassiveEdge(start, end, lhs, out);\r\n    }\r\n    \r\n    // try to add the edge; if successful, also add it to the agenda\r\n    if (chart.add(edge)) {\r\n      LOG(\"+ \" + inference + \": \" + edge);\r\n      agenda.push(edge);\r\n    }\r\n  }\r\n  \r\n  // seed the agenda with the starting rule\r\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\r\n  \r\n  // main loop\r\n  while (agenda.length > 0) {\r\n    var edge = agenda.pop();\r\n    var start= edge.start;\r\n    var end  = edge.end;\r\n    var lhs  = edge.lhs;\r\n    var next = edge.next;\r\n    LOG(edge);\r\n\r\n    if (edge.isPassive) {\r\n      // combine\r\n      var actives = chart.actives[start][lhs];\r\n      for (var i in actives) {\r\n\tvar active = actives[i];\r\n\tvar rules = clone(active.rules);\r\n\tvar text = active.text;\r\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\r\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\r\n\t    rules[edge.lhs] = text[edge.lhs];\r\n\t} else {\r\n        rules[edge.lhs] = clone(edge.out);\r\n    }\r\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\r\n      }\r\n\r\n    } else if (next.constructor == SRGS.RefClass) {\r\n      var ref = next.content;\r\n      // combine\r\n      var passives = chart.passives[end][ref];\r\n      for (var i in passives) {\r\n\tvar passive = passives[i];\r\n\tvar rules = clone(edge.rules);\r\n\tvar text = edge.text;\r\n\trules[passive.lhs] = clone(passive.out);\r\n\ttext[passive.lhs] = passive.text;\r\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\r\n      }\r\n      // predict\r\n      if (ref in grammar) {\r\n\tif (leftCornerFilter(ref, end)) {\r\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\r\n\t}\r\n      }\r\n\r\n    } else if (next == words[end]) {\r\n      // scan\r\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\r\n    }\r\n  }\r\n\r\n  return chart;\r\n}\r\n\r\n\r\n","//\r\n//  runparser.js\r\n//\r\n/*\r\n  The author or authors of this code dedicate any and all \r\n  copyright interest in this code to the public domain.\r\n*/\r\n\r\n\r\n// helper functions for the parser demo\r\n\r\nimport * as SRGS from './srgs'\r\n\r\nfunction getElement(id) {\r\n  return document.getElementById(id);\r\n}\r\n\r\nfunction appendElement(parent, element, text) {\r\n  var elem = document.createElement(element);\r\n  if (text)\r\n    elem.appendChild(document.createTextNode(text));\r\n  parent.appendChild(elem);\r\n  return elem\r\n}\r\n\r\nfunction runParser(input) {\r\n  var resultsDiv = getElement(\"results\");\r\n  resultsDiv.innerHTML = \"\";\r\n  var maybeFilter;\r\n  if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\r\n    maybeFilter = filter;\r\n    appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\r\n  }\r\n  var startTime = new Date();\r\n  var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\r\n  var parseTime = new Date() - startTime;\r\n  var parseResults = parseChart.resultsForRule(grammar.$root);\r\n  \r\n  console.log(parseResults[0]);\r\n  \r\n  if (parseResults) {\r\n    for (var i in parseResults) {\r\n        resultsDiv.innerHTML += display(parseResults[i],\"\");\r\n    }\r\n  } else {\r\n    appendElement(resultsDiv, \"P\", \"No results found!\");\r\n  }\r\n  \r\n/*\r\n  if (parseResults) { \r\n    var resultList = appendElement(resultsDiv, \"OL\");\r\n    for (var i in parseResults) \r\n      appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\r\n  } else {\r\n    appendElement(resultsDiv, \"P\", \"No results found!\");\r\n  }\r\n*/\r\n  var statistics = parseChart.statistics()\r\n  appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\r\n\t\t\" (\" + statistics.nrPassiveEdges + \" passive)\");\r\n  appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" + \r\n\t\t\" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\r\n}\r\n\r\nfunction runWordParser() {\r\n  runParser(getElement(\"input\").value.split(/\\s+/));\r\n}\r\n\r\nfunction runCharacterParser() {\r\n  runParser(getElement(\"input\").value.split(\"\"));\r\n}\r\n\r\nexport function loadGrammar(str) {\r\n    var dom = parseXML(str);\r\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\r\n    var grammar = new SRGS.Grammar(root);\r\n    var xrules = dom.getElementsByTagName(\"rule\");\r\n    for(var r=0; r < xrules.length; r++) {\r\n        var xrule = xrules[r];\r\n        var id = xrule.getAttribute(\"id\");\r\n        grammar[id] = processRuleExpansions(xrule);\r\n    }\r\n    return grammar;\r\n}\r\n\r\nfunction processRuleExpansions(xrule) {\r\n    var xitems = xrule.childNodes;\r\n    var rule = [];\r\n    for(var i=0; i < xitems.length; i++) {\r\n        if (xitems[i].nodeType == 3) {\r\n            var str = xitems[i].textContent.trim();\r\n            if (str != \"\") {\r\n                rule.push(str.split(/ +/));\r\n            }\r\n        } else if (xitems[i].nodeType == 1) {\r\n            if (xitems[i].nodeName == \"token\") {\r\n                rule.push(SRGS.Tag(xitems[i].textContent));\r\n            } else if (xitems[i].nodeName == \"ruleref\") {\r\n                var uri = xitems[i].getAttribute(\"uri\");\r\n                rule.push(SRGS.Ref(uri.slice(1)));\r\n            } else if (xitems[i].nodeName == \"tag\") {\r\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\r\n            } else if (xitems[i].nodeName == \"one-of\") {\r\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\r\n            } else if (xitems[i].nodeName == \"item\") {\r\n                var repeat = xitems[i].getAttribute(\"repeat\");\r\n                if (!repeat) {\r\n                    rule.push(processRuleExpansions(xitems[i]));\r\n                } else {\r\n                    var r = repeat.split(\"-\");\r\n                    var min = parseInt(r[0]);\r\n                    var max = parseInt(r[1]);\r\n                    max = (max) ? max : Infinity;\r\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\r\n                }\r\n            } else {\r\n                console.log(xitems[i]);\r\n            }\r\n        }\r\n    }\r\n\treturn rule;\r\n}\r\n\r\nfunction parseXML(text) {\r\n    if (typeof DOMParser != \"undefined\") {\r\n        // Mozilla, Firefox, and related browsers\r\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\r\n    }\r\n    else if (typeof ActiveXObject != \"undefined\") {\r\n        // Internet Explorer.\r\n        var doc = XML.newDocument();  // Create an empty document\r\n        doc.loadXML(text);            // Parse text into it\r\n        return doc;                   // Return it\r\n    }\r\n    else {\r\n        // As a last resort, try loading the document from a data: URL\r\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\r\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\r\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"GET\", url, false);\r\n        request.send(null);\r\n        return request.responseXML;\r\n    }\r\n};\r\n","import { MachineConfig, send, Action, assign, TransitionConfigOrTarget } from \"xstate\";\r\nimport { loadGrammar } from './runparser';\r\nimport { parse } from './chartparser';\r\nimport { grammar } from './grammars/puzzleGrammar';\r\n\r\nconst gram = loadGrammar(grammar);\r\nconst commands = [\"help\", \"reset\", \"stop\"];\r\n\r\nfunction getGrammarResult(recResult: string) {\r\n    let res = parse(recResult.toLowerCase().split(/\\s+/), gram);\r\n\r\n    // return undefined if grammar result is not found\r\n    return res.resultsForRule(gram.$root)[0] ?\r\n        res.resultsForRule(gram.$root)[0].puzzleMove : undefined;\r\n}\r\n\r\nfunction say(text: string): Action<SDSContext, SDSEvent> {\r\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\r\n}\r\n\r\nfunction getDefaultStates(prompt: string): any {\r\n    return {\r\n        prompt: {\r\n            on: { ENDSPEECH: \"listen\" },\r\n            entry: send((context) => ({\r\n                type: \"SPEAK\",\r\n                value: prompt\r\n            })),\r\n        },\r\n        reprompt: {\r\n            on: { ENDSPEECH: \"listen\" },\r\n            entry: send((context: SDSContext) => ({\r\n                type: \"SPEAK\",\r\n                value: `I heard you say ${context.recResult}. Could you repeat what you mean?`\r\n            })),\r\n        },\r\n        listen: {\r\n            entry: send('LISTEN')\r\n        }\r\n    }\r\n}\r\n\r\nfunction getDefaultEvents(help_msg: string): any {\r\n    return [\r\n        {\r\n            target: \"redirect\",\r\n            cond: (context: SDSContext) => getGrammarResult(context.recResult),\r\n            actions: assign((context: SDSContext) => {\r\n                return {\r\n                    piece: context.piece ? context.piece : getGrammarResult(context.recResult).piece,\r\n                    degree: context.degree ? context.degree : getGrammarResult(context.recResult).degree,\r\n                    direction: context.direction ? context.direction : getGrammarResult(context.recResult).direction,\r\n                }\r\n            }),\r\n        },\r\n        {\r\n            cond: (context: SDSContext) => context.recResult === \"help\",\r\n            actions: assign((context: SDSContext) => { return { help_msg: help_msg } }),\r\n            target: \"#root.dm.help\"\r\n        },\r\n        // reprompt on unrecognised\r\n        {\r\n            target: \".reprompt\",\r\n            cond: (context: SDSContext) => commands.indexOf(context.recResult) < 0,\r\n        }\r\n    ]\r\n}\r\n\r\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'init',\r\n    states: {\r\n        init: {\r\n            on: {\r\n                CLICK: 'welcome'\r\n            }\r\n        },\r\n        welcome: {\r\n            on: { ENDSPEECH: \"shuffle\" },\r\n            entry: say(\"Let's begin by shuffling the pieces.\")\r\n        },\r\n        // just an extra state to add a bit more natural dialog\r\n        afterShuffle: {\r\n            on: { ENDSPEECH: \"play\" },\r\n            entry: say(\"Now...\")\r\n        },\r\n        play: {\r\n            on: {\r\n                RECOGNISED: {\r\n                    cond: (context) => context.recResult === \"reset\" || context.recResult === \"stop\",\r\n                    target: \"#root.dm.reset\"\r\n                }\r\n            },\r\n            id: \"play\",\r\n            initial: \"piece\",\r\n            states: {\r\n                hist: {\r\n                    type: 'history',\r\n                    history: 'shallow'\r\n                },\r\n                // redirect user to correct substate based on how much information they give\r\n                redirect: {\r\n                    always: [\r\n                        {\r\n                            target: '#root.dm.rotate',\r\n                            cond: (context) => context.piece !== undefined\r\n                                && context.degree !== undefined\r\n                                && context.direction !== undefined\r\n                        },\r\n                        // if degree is twice/180, dont bother asking for direction\r\n                        {\r\n                            target: '#root.dm.rotate',\r\n                            cond: (context) => context.piece !== undefined\r\n                                && context.degree === 180\r\n                        },\r\n                        {\r\n                            target: '#play.direction',\r\n                            cond: (context) => context.piece !== undefined\r\n                                && context.pieceSelected === true\r\n                                && context.degree !== undefined\r\n                        },\r\n                        {\r\n                            target: '#play.degree',\r\n                            cond: (context) => context.piece !== undefined\r\n                                && context.pieceSelected === true\r\n                        },\r\n                        // select piece also in case like \"top left 90 degrees\" as the first utterance\r\n                        {\r\n                            target: '#root.dm.select',\r\n                            cond: (context) => context.piece !== undefined ||\r\n                                (context.piece !== undefined\r\n                                    && context.degree !== undefined),\r\n                        },\r\n                        // go back to piece state if it has not been specified\r\n                        // in case of only \"right\" reset the direction\r\n                        {\r\n                            target: \"piece\",\r\n                            actions: assign((context) => {\r\n                                return {\r\n                                    direction: undefined\r\n                                }\r\n                            })\r\n                        }\r\n                    ]\r\n                },\r\n                piece: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [\r\n                            ...getDefaultEvents(\"First tell me the row name and then the column name.\")\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        ...getDefaultStates(\"Which piece would you like to rotate?\")\r\n                    }\r\n                },\r\n                degree: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [\r\n                            ...getDefaultEvents(\"Tell me either a degree or a number of times to rotate.\")\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        ...getDefaultStates(\"How much do you want to rotate it?\")\r\n                    }\r\n                },\r\n                direction: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [\r\n                            ...getDefaultEvents(\"I can go either clockwise or counter clockwise.\")\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        ...getDefaultStates(\"In which direction should I rotate it?\")\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        help: {\r\n            on: { ENDSPEECH: \"#root.dm.play.hist\" },\r\n            entry: send((context) => ({\r\n                type: \"SPEAK\",\r\n                value: `${context.help_msg}`\r\n            })),\r\n        },\r\n        win: {\r\n            on: { ENDSPEECH: \"init\" },\r\n            entry: say(\"You win! Congrats!\")\r\n        },\r\n        lose: {\r\n            initial: \"prompt\",\r\n            on: {\r\n                RECOGNISED: [{\r\n                    target: 'reset',\r\n                    cond: (context) => context.recResult === \"no\"\r\n                },\r\n                {\r\n                    target: 'welcome',\r\n                    cond: (context) => context.recResult === \"yes\"\r\n                }]\r\n            },\r\n            states: {\r\n                ...getDefaultStates(\"You used up all your turns! Do you want to start over?\")\r\n            }\r\n        },\r\n        afterRotate: {\r\n            on: { ENDSPEECH: \"play\" },\r\n            entry: say(\"There you go! Let's continue.\")\r\n        },\r\n        rotate: {\r\n            on: {\r\n                WIN: {\r\n                    target: \"win\",\r\n                    actions: assign((context) => {\r\n                        return {\r\n                            piece: undefined,\r\n                            degree: undefined,\r\n                            direction: undefined,\r\n                            moves: undefined,\r\n                            pieceSelected: false\r\n                        }\r\n                    }),\r\n                },\r\n                CONTINUE: {\r\n                    target: \"afterRotate\",\r\n                    actions: assign((context) => {\r\n                        // reset moves after each turn\r\n                        return {\r\n                            piece: undefined,\r\n                            degree: undefined,\r\n                            direction: undefined,\r\n                            pieceSelected: false,\r\n                            moves: context.moves ? context.moves + 1 : 1\r\n                        }\r\n                    }),\r\n                },\r\n                LOSE: {\r\n                    target: \"lose\",\r\n                    actions: assign((context) => {\r\n                        return {\r\n                            piece: undefined,\r\n                            degree: undefined,\r\n                            direction: undefined,\r\n                            moves: undefined,\r\n                            pieceSelected: false\r\n                        }\r\n                    }),\r\n                }\r\n            },\r\n            entry: \"rotatePiece\",\r\n        },\r\n        select: {\r\n            entry: \"selectPiece\",\r\n            always: {\r\n                target: \"play.redirect\",\r\n                actions: assign((context) => {\r\n                    return {\r\n                        pieceSelected: true\r\n                    }\r\n                }),\r\n            }\r\n        },\r\n        shuffle: {\r\n            entry: \"shufflePieces\",\r\n            always: \"afterShuffle\"\r\n        },\r\n        reset: {\r\n            entry: \"resetBoard\",\r\n            always: \"init\"\r\n        }\r\n    }\r\n})","export const grammar = `<grammar root=\"puzzleMove\">\r\n<rule id=\"puzzleMove\">\r\n   <item repeat=\"0-1\">\r\n   <ruleref uri=\"#piece\"/>\r\n   </item>\r\n   <item repeat=\"0-1\">\r\n   <ruleref uri=\"#degree\"/>\r\n   </item>\r\n   <item repeat=\"0-1\">\r\n   <ruleref uri=\"#direction\"/>\r\n   </item>\r\n   <tag>out.puzzleMove = new Object(); out.puzzleMove.piece=rules.piece;\r\n   out.puzzleMove.degree=rules.degree; out.puzzleMove.direction=rules.direction;</tag>\r\n</rule>\r\n<rule id=\"piece\">\r\n   <one-of>\r\n      <item>top left<tag>out=\"top-left\";</tag></item> \r\n      <item>top center<tag>out=\"top-center\";</tag></item>\r\n      <item>top centre<tag>out=\"top-center\";</tag></item>\r\n      <item>top right<tag>out=\"top-right\";</tag></item> \r\n      <item>middle left<tag>out=\"middle-left\";</tag></item> \r\n      <item>middle center<tag>out=\"middle-center\";</tag></item> \r\n      <item>middle centre<tag>out=\"middle-center\";</tag></item> \r\n      <item>middle right<tag>out=\"middle-right\";</tag></item> \r\n      <item>bottom left<tag>out=\"bottom-left\";</tag></item> \r\n      <item>bottom center<tag>out=\"bottom-center\";</tag></item> \r\n      <item>bottom centre<tag>out=\"bottom-center\";</tag></item> \r\n      <item>bottom right<tag>out=\"bottom-right\";</tag></item> \r\n   </one-of>\r\n</rule>\r\n<rule id=\"degree\">\r\n   <one-of>\r\n      <item>\r\n         <one-of>\r\n            <item>0<tag>out=0;</tag></item>\r\n            <item>90<tag>out=90;</tag></item>\r\n            <item>180<tag>out=180;</tag></item>\r\n            <item>270<tag>out=270;</tag></item>\r\n            <item>360<tag>out=360;</tag></item>\r\n         </one-of>\r\n         <item repeat=\"0-1\">degrees</item>\r\n      </item>\r\n      <item>90°<tag>out=90;</tag></item>\r\n      <item>180°<tag>out=180;</tag></item>\r\n      <item>270°<tag>out=270;</tag></item>\r\n      <item>once <tag>out=90;</tag></item>\r\n      <item>one <tag>out=90;</tag></item>\r\n      <item>ones <tag>out=90;</tag></item>\r\n      <item>1 <tag>out=90;</tag></item>\r\n      <item>one time <tag>out=90;</tag></item>\r\n      <item>1 time <tag>out=90;</tag></item>\r\n      <item>1 * <tag>out=90;</tag></item>\r\n      <item>twice <tag>out=180;</tag></item>\r\n      <item>two <tag>out=180;</tag></item>\r\n      <item>2 <tag>out=180;</tag></item>\r\n      <item>two times <tag>out=180;</tag></item>\r\n      <item>2 times <tag>out=180;</tag></item>\r\n      <item>2 * <tag>out=180;</tag></item>\r\n      <item>three times <tag>out=270;</tag></item>\r\n      <item>3 times <tag>out=270;</tag></item>\r\n      <item>3 <tag>out=270;</tag></item>\r\n      <item>3 * <tag>out=270;</tag></item>\r\n   </one-of>\r\n</rule>\r\n<rule id=\"direction\">\r\n   <one-of>\r\n      <item>\r\n         <item repeat=\"0-1\">to the</item>\r\n         <one-of>\r\n            <item>left<tag>out=\"left\";</tag></item>\r\n            <item>right<tag>out=\"right\";</tag></item>\r\n         </one-of>\r\n      </item>\r\n      <item>clockwise<tag>out=\"right\";</tag></item>\r\n      <item>counterclockwise<tag>out=\"left\";</tag></item>\r\n   </one-of>\r\n</rule>\r\n</grammar>\r\n`","import { MachineConfig, send, assign } from \"xstate\";\r\nimport { loadGrammar } from './runparser';\r\nimport { parse } from './chartparser';\r\nimport { grammar } from './grammars/settingsGrammar';\r\n\r\nconst gram = loadGrammar(grammar);\r\n\r\nfunction getGrammarResult(recResult: string) {\r\n    let res = parse(recResult.toLowerCase().split(/\\s+/), gram);\r\n    return res.resultsForRule(gram.$root)[0] ? res.resultsForRule(gram.$root)[0].setting : undefined;\r\n}\r\n\r\nfunction ask(prompt: string): any {\r\n    return {\r\n        prompt: {\r\n            on: { ENDSPEECH: \"listen\" },\r\n            entry: send((context) => ({\r\n                type: \"SPEAK\",\r\n                value: prompt\r\n            })),\r\n        },\r\n        listen: {\r\n            entry: send('LISTEN')\r\n        }\r\n    }\r\n}\r\n\r\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'init',\r\n    // allow user to exit at any point\r\n    on: {\r\n        RECOGNISED: {\r\n            target: '#root.settings.init',\r\n            cond: (context) => context.recResult == \"exit\",\r\n        }\r\n    },\r\n    states: {\r\n        init: {\r\n            on: {\r\n                SETTINGS: 'welcome'\r\n            }\r\n        },\r\n        welcome: {\r\n            initial: \"prompt\",\r\n            on: {\r\n                RECOGNISED: [\r\n                    {\r\n                        target: 'image',\r\n                        cond: (context) => getGrammarResult(context.recResult) == \"image\",\r\n                    },\r\n                    {\r\n                        target: 'mode',\r\n                        cond: (context) => getGrammarResult(context.recResult) == \"mode\",\r\n                    },\r\n                    { target: \".prompt\" }\r\n                ]\r\n            },\r\n            states: {\r\n                ...ask(\"Here are the settings. Which one would you like to select?\")\r\n            }\r\n        },\r\n        image: {\r\n            initial: \"prompt\",\r\n            on: {\r\n                RECOGNISED: \".afterAnswer\"\r\n            },\r\n            states: {\r\n                ...ask(\"What would you like to see a picture of?\"),\r\n                // a state to inform user to wait for result\r\n                afterAnswer: {\r\n                    entry: send((context) => ({\r\n                        type: \"SPEAK\",\r\n                        value: `Good choice. Give me just a second and I will get an image of that for you.`\r\n                    })),\r\n                    on: {\r\n                        ENDSPEECH: {\r\n                            target: \"change\",\r\n                            actions: assign((context) => {\r\n                                return {\r\n                                    image: \"https://source.unsplash.com/weekly?\" + context.recResult\r\n                                }\r\n                            }),\r\n                        }\r\n                    }\r\n                },\r\n                change: {\r\n                    entry: \"changeImage\",\r\n                    always: \"confirm\",\r\n                },\r\n                confirm: {\r\n                    entry: send((context) => ({\r\n                        type: \"SPEAK\",\r\n                        value: `Here you go, a nice picture of ${context.recResult}`\r\n                    })),\r\n                    on: { ENDSPEECH: \"#root.settings.init\" }\r\n                },\r\n                error: {\r\n                    entry: send((context) => ({\r\n                        type: \"SPEAK\",\r\n                        value: `Something happened and I could not get your image. `\r\n                    })),\r\n                    on: { ENDSPEECH: \"#root.settings.init\" }\r\n                }\r\n            }\r\n        },\r\n        mode: {\r\n            initial: \"prompt\",\r\n            on: {\r\n                RECOGNISED: [\r\n                    {\r\n                        target: '.confirm',\r\n                        cond: (context) => context.recResult == \"hard\" || context.recResult == \"normal\",\r\n                        actions: assign((context) => { return { mode: context.recResult } }),\r\n                    },\r\n                    {\r\n                        target: '.prompt',\r\n                    }\r\n                ]\r\n            },\r\n            states: {\r\n                ...ask(\"Do you want to play in normal or hard mode?\"),\r\n                confirm: {\r\n                    entry: send((context) => ({\r\n                        type: \"SPEAK\",\r\n                        value: `Okay let's play in ${context.mode} mode!`\r\n                    })),\r\n                    on: { ENDSPEECH: \"#root.settings.init\" }\r\n                }\r\n            }\r\n        }\r\n    }\r\n})","export const grammar = `\r\n<grammar root=\"puzzleMove\">\r\n<rule id=\"puzzleMove\">\r\n   <item repeat=\"0-1\">change</item>\r\n   <ruleref uri=\"#setting\"/>\r\n   <tag>out.setting = rules.setting</tag>\r\n</rule>\r\n<rule id=\"setting\">\r\n   <one-of>\r\n      <item>image</item> \r\n      <item>mode</item> \r\n   </one-of>\r\n</rule>\r\n</grammar>\r\n`","import \"./styles.scss\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Machine, assign, actions, State } from \"xstate\";\r\nimport { useMachine, asEffect } from \"@xstate/react\";\r\nimport { inspect } from \"@xstate/inspect\";\r\nimport { dmMachine as dmMachinePuzzle } from \"./dmPuzzle\";\r\nimport { dmMachine as dmMachineSettings } from \"./dmSettings\";\r\nconst { send, cancel } = actions;\r\n\r\ninspect({\r\n    url: \"https://statecharts.io/inspect\",\r\n    iframe: false,\r\n});\r\n\r\nimport { useSpeechSynthesis, useSpeechRecognition } from \"react-speech-kit\";\r\n\r\nconst machine = Machine<SDSContext, any, SDSEvent>(\r\n    {\r\n        id: \"root\",\r\n        type: \"parallel\",\r\n        states: {\r\n            dm: {\r\n                ...dmMachinePuzzle,\r\n            },\r\n            settings: {\r\n                ...dmMachineSettings,\r\n            },\r\n            asrtts: {\r\n                initial: \"idle\",\r\n                states: {\r\n                    idle: {\r\n                        on: {\r\n                            LISTEN: \"recognising\",\r\n                            SPEAK: {\r\n                                target: \"speaking\",\r\n                                actions: assign((_context, event) => {\r\n                                    return { ttsAgenda: event.value };\r\n                                }),\r\n                            },\r\n                        },\r\n                    },\r\n                    recognising: {\r\n                        initial: \"progress\",\r\n                        entry: \"recStart\",\r\n                        exit: \"recStop\",\r\n                        on: {\r\n                            ASRRESULT: {\r\n                                actions: [\r\n                                    \"recLogResult\",\r\n                                    assign((_context, event) => {\r\n                                        return { recResult: event.value };\r\n                                    }),\r\n                                ],\r\n                                target: \".match\",\r\n                            },\r\n                            RECOGNISED: {\r\n                                actions: [\r\n                                    cancel(\r\n                                        \"maxsp\"\r\n                                    ),\r\n                                ],\r\n                                target: \"idle\",\r\n                            }\r\n                        },\r\n                        states: {\r\n                            progress: {},\r\n                            match: {\r\n                                entry: send(\"RECOGNISED\"),\r\n                            },\r\n                        },\r\n                    },\r\n                    speaking: {\r\n                        entry: \"ttsStart\",\r\n                        on: {\r\n                            ENDSPEECH: \"idle\",\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    },\r\n    {\r\n        actions: {\r\n            recLogResult: (context: SDSContext) => {\r\n                console.log(\"<< ASR: \" + context.recResult);\r\n            },\r\n            test: () => {\r\n                console.log(\"test\");\r\n            },\r\n            // logIntent: (context: SDSContext) => {\r\n            //     console.log(\"<< NLU intent: \" + context.nluData.intent.name);\r\n            // },\r\n        },\r\n    }\r\n);\r\n\r\ninterface Props extends React.HTMLAttributes<HTMLElement> {\r\n    state: State<SDSContext, any, any, any>;\r\n}\r\n\r\nconst ReactiveButton = (props: Props): JSX.Element => {\r\n    switch (true) {\r\n        case props.state.matches({ asrtts: \"recognising\" }):\r\n            return (\r\n                <button type=\"button\"{...props}>\r\n                    Listening...\r\n                </button>\r\n            );\r\n        case props.state.matches({ asrtts: \"speaking\" }):\r\n            return (\r\n                <button type=\"button\" {...props}>\r\n                    Speaking...\r\n                </button>\r\n            );\r\n        default:\r\n            return (\r\n                <button type=\"button\" className=\"start-btn\" {...props}>\r\n                    Click to play\r\n                </button>\r\n            );\r\n    }\r\n};\r\n\r\n// track when user has solved the puzzle\r\nlet finishedPiecesCount = 0\r\nconst piecesCount = 9\r\n\r\nfunction App() {\r\n    const { speak, cancel, speaking } = useSpeechSynthesis({\r\n        onEnd: () => {\r\n            send(\"ENDSPEECH\");\r\n        },\r\n    });\r\n    const { listen, listening, stop } = useSpeechRecognition({\r\n        onResult: (result: any) => {\r\n            send({ type: \"ASRRESULT\", value: result });\r\n        },\r\n    });\r\n    const [current, send, service] = useMachine(machine, {\r\n        devTools: true,\r\n        actions: {\r\n            recStart: asEffect(() => {\r\n                console.log(\"Ready to receive a command.\");\r\n                listen({\r\n                    interimResults: false,\r\n                    continuous: true,\r\n                });\r\n            }),\r\n            recStop: asEffect(() => {\r\n                console.log(\"Recognition stopped.\");\r\n                stop();\r\n            }),\r\n            ttsStart: asEffect((context, effect) => {\r\n                console.log(\"Speaking...\");\r\n                speak({ text: context.ttsAgenda });\r\n            }),\r\n            ttsCancel: asEffect((context, effect) => {\r\n                console.log(\"TTS STOP...\");\r\n                cancel();\r\n            }),\r\n            rotatePiece: asEffect((context) => {\r\n                const pieceId = context.piece;\r\n                const piece = document.getElementById(pieceId);\r\n\r\n                if (piece) {\r\n                    // get the new degree\r\n                    let currDegree = piece.style.transform.match(/\\d+/)[0];\r\n                    let degree = getDegree(parseInt(currDegree), parseInt(context.degree),\r\n                        context.direction);\r\n                    piece.style.transform = `rotate(${degree}deg)`; // set degree as rotate value\r\n                    piece.classList.remove(\"selected\"); // remove selected class\r\n\r\n                    // track pieces that are turned the right way (at 0 degrees)\r\n                    if (parseInt(currDegree) === 0 && degree !== 0) finishedPiecesCount--;\r\n                    if (degree === 0) finishedPiecesCount++;\r\n\r\n                    // in hard mode allow user to try only as many times as there are pieces\r\n                    // trigger win or continue event based on count of \"finished\" pieces \r\n                    if (context.mode === \"hard\" && context.moves === piecesCount)\r\n                        send(\"LOSE\");\r\n                    else if (finishedPiecesCount === piecesCount)\r\n                        send(\"WIN\");\r\n                    else\r\n                        send(\"CONTINUE\");\r\n                }\r\n            }),\r\n            shufflePieces: asEffect((context) => {\r\n                const board = document.getElementById(\"board\");\r\n                const labels = document.getElementById(\"labels\");\r\n                const info = document.getElementById(\"info\");\r\n\r\n                if (board) {\r\n                    board.classList.add(\"playing\");\r\n                    labels.classList.remove(\"hidden\");\r\n                    info.classList.remove(\"hidden\");\r\n\r\n                    const pieces = board.children;\r\n\r\n                    let degrees = [90, 180, 270];\r\n                    // include 0 degrees (no rotation) only in normal mode\r\n                    if (context.mode !== \"hard\") {\r\n                        degrees.push(0);\r\n                    }\r\n\r\n                    for (let i = 0; i < pieces.length; i++) {\r\n                        const htmlElement = document.getElementById(pieces[i].id);\r\n\r\n                        // typescript forcing strict null checks\r\n                        if (htmlElement) {\r\n                            let randomDegree = degrees[Math.floor(Math.random() * degrees.length)];\r\n                            htmlElement.style.transform = `rotate(${randomDegree}deg)`;\r\n\r\n                            if (randomDegree === 0) finishedPiecesCount++;\r\n                        }\r\n                    }\r\n                }\r\n            }),\r\n            resetBoard: asEffect((context) => {\r\n                const board = document.getElementById(\"board\");\r\n                const labels = document.getElementById(\"labels\");\r\n                const info = document.getElementById(\"info\");\r\n                if (board) {\r\n                    // reset classes to hide things\r\n                    board.classList.remove(\"playing\");\r\n                    labels.classList.add(\"hidden\");\r\n                    info.classList.add(\"hidden\");\r\n\r\n                    const pieces = board.children;\r\n\r\n                    for (let i = 0; i < pieces.length; i++) {\r\n                        const htmlElement = document.getElementById(pieces[i].id);\r\n\r\n                        // typescript forcing strict null checks\r\n                        if (htmlElement) htmlElement.style.transform = \"rotate(0)\";\r\n                    }\r\n                }\r\n            }),\r\n            selectPiece: asEffect((context) => {\r\n                const pieceId = context.piece;\r\n                const piece = document.getElementById(pieceId);\r\n\r\n                if (piece) {\r\n                    // apply selected styles to piece\r\n                    let transformVal = piece.style.transform + \" scale(1.1)\";\r\n                    piece.style.transform = transformVal;\r\n                    piece.classList.add(\"selected\");\r\n                }\r\n            }),\r\n            changeImage: asEffect((context) => {\r\n                const board = document.getElementById(\"board\");\r\n                if (board) {\r\n                    board.classList.remove(\"playing\");\r\n                    const pieces = board.children;\r\n\r\n                    for (let i = 0; i < pieces.length; i++) {\r\n                        const htmlElement = document.getElementById(pieces[i].id);\r\n\r\n                        // typescript forcing strict null checks\r\n                        if (htmlElement) htmlElement.style.backgroundImage = `url(${context.image})`;\r\n                    }\r\n                }\r\n            })\r\n        },\r\n    });\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <div className=\"btn-wrapper\">\r\n                <ReactiveButton state={current} onClick={() => send(\"CLICK\")} />\r\n                <button type=\"button\" className=\"settings-btn\" onClick={() => send(\"SETTINGS\")}>Settings</button>\r\n            </div>\r\n\r\n            {renderSettings(current.value)}\r\n            {renderBoard()}\r\n\r\n            <div className=\"info hidden\" id=\"info\">\r\n                <span>\r\n                    Say <b>help</b> at any point for a help message.\r\n                    Want to stop playing? Say <b>reset</b> or <b>stop</b> and the pieces will be organized for you.\r\n                </span>\r\n            </div>\r\n\r\n        </div>\r\n    );\r\n}\r\n\r\n// get the puzzle piece board\r\nfunction renderBoard() {\r\n    return (\r\n        <div>\r\n            <div className=\"hidden\" id=\"labels\">\r\n                <div className=\"column-names\"><div><span>left</span></div><div><span>center</span></div><div><span>right</span></div></div>\r\n                <div className=\"row-names\"><div><span>top</span></div><div><span>middle</span></div><div><span>bottom</span></div></div>\r\n            </div>\r\n\r\n            <div className=\"board\" id=\"board\">\r\n                <div className=\"top-left\" id=\"top-left\"></div>\r\n                <div className=\"top-center\" id=\"top-center\"></div>\r\n                <div className=\"top-right\" id=\"top-right\"></div>\r\n                <div className=\"middle-left\" id=\"middle-left\"></div>\r\n                <div className=\"middle-center\" id=\"middle-center\"></div>\r\n                <div className=\"middle-right\" id=\"middle-right\"></div>\r\n                <div className=\"bottom-left\" id=\"bottom-left\"></div>\r\n                <div className=\"bottom-center\" id=\"bottom-center\"></div>\r\n                <div className=\"bottom-right\" id=\"bottom-right\"></div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\n// get a visual of settings\r\nfunction renderSettings(currentValue: any) {\r\n    return (\r\n        currentValue.settings !== \"init\" ?\r\n            <div className=\"settings\">Settings:\r\n                <ul>\r\n                    <li>Change mode</li>\r\n                    <li>Change image</li>\r\n                    <li>Exit</li>\r\n                </ul></div> : null\r\n    );\r\n}\r\n\r\nfunction getDegree(currDegree: number, degreeToRotate: number, direction: string): number {\r\n    let degree = 0;\r\n\r\n    // add or subtract degree and current degree, rotate to correct direction (default is right)\r\n    if (direction == \"left\") {\r\n        degree = currDegree - degreeToRotate;\r\n\r\n        if (degree < 0)\r\n            degree = currDegree + degreeToRotate;\r\n    } else {\r\n        degree = currDegree + degreeToRotate;\r\n\r\n        if (degree > 360)\r\n            degree = currDegree - degreeToRotate;\r\n    }\r\n\r\n    // don't exceed 360deg\r\n    if (degree === 360) degree = 0;\r\n\r\n    return degree;\r\n}\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(<App />, rootElement);"],"sourceRoot":""}